# Architecture of the Mine Disaster Response Algorithms

**Last Updated:** 2025-12-08
**Owner:** Data Team

This document outlines the architecture of the core algorithmic components of the Mine Disaster Response system. These modules are responsible for processing raw sensor data, estimating miner locations, and calculating safe navigation paths.

## 1. Core Principles

- **Modularity**: Each component has a single, well-defined responsibility (e.g., signal processing, localization, pathfinding). This makes the system easier to test, debug, and upgrade.
- **Statelessness (where possible)**: Components like the `solver` and `fingerprint_matcher` are stateless; they take data in and produce a result without retaining memory of past requests.
- **Centralized State Management**: All dynamic information (miner locations, statuses, navigation queues) is managed by a single, stateful component, the `MinerStateManager`, which acts as the single source of truth.

## 2. Component Breakdown

The `algorithms` package is composed of six primary modules that work in a sequential pipeline.

| File | Component Class | Responsibility |
| :--- | :--- | :--- |
| `maze_creation.py` | (Procedural) | **Map Definition**: Defines the static mine layout, including walls, passages, and exits. |
| `rssi_preprocessing.py` | `RSSIPreprocessor` | **Signal Cleaning**: Filters and stabilizes noisy raw RSSI (Bluetooth) data. |
| `fingerprint_matching.py`| `FingerprintMatcher`| **Localization**: Estimates a miner's `(x, y)` coordinates from cleaned RSSI data. |
| `state_management.py` | `MinerStateManager` | **State Tracking**: Acts as the central "brain," maintaining the real-time state of all miners. |
| `solver.py` | (Procedural) | **Pathfinding**: Calculates the shortest path from a miner's location to the nearest exit. |
| `navigation.py` | (Procedural) | **Instruction Generation**: Converts a coordinate path into simple, actionable move commands. |

## 3. Data Flow and Interconnection

The system operates in a continuous loop, processing data from miners and generating navigation instructions. The diagram and steps below illustrate the flow for a single miner's data packet.

```
[Miner Device] -> [Raw RSSI Data]
       |
       v
1. RssiPreprocessor
       |
       v
[Cleaned RSSI Vector]
       |
       v
2. FingerprintMatcher (with Radio Map)
       |
       v
[Estimated (x, y) Location]
       |
       v
3. MinerStateManager (Update State)
       |
       v
4. solver.py (using map from maze_creation.py)
       |
       v
[Coordinate Path to Exit]
       |
       v
5. navigation.py
       |
       v
[Move Sequence: 'F', 'L', 'F'...] -> [MinerStateManager] -> [Miner Device]
```

### Step-by-Step Data Pipeline:

1.  **Signal Reception and Cleaning**: The main application (e.g., on the Raspberry Pi gateway) receives a batch of raw RSSI readings from a miner. It passes this data to an instance of the `RSSIPreprocessor`. The preprocessor returns a single, stable RSSI vector.

2.  **Location Estimation**: The clean RSSI vector is passed to the `FingerprintMatcher`. The matcher loads a pre-trained radio map (a JSON file) and compares the miner's RSSI "fingerprint" to the map, calculating the most probable `(x, y)` coordinates.

3.  **State Update**: The estimated location and a confidence score are sent to the `MinerStateManager`. The state manager updates its internal record for that miner, storing the new location, timestamp, and status. This is the **single source of truth**.

4.  **Path Calculation**: The application retrieves the miner's updated location from the `MinerStateManager` and passes it to the `solver.solve_maze_to_nearest_exit()` function. This function also requires the digitized mine map (generated by `maze_creation.py`) to understand the layout. The solver returns a list of coordinates representing the shortest path to an exit.

5.  **Instruction Generation**: This list of coordinates is passed to the `navigation.convert_coordinate_stack_to_move_sequence()` function. It translates the path into a simple array of move commands (e.g., `['F', 'F', 'R', 'F']`).

6.  **Dispatching Commands**: The generated move sequence is stored back into the `MinerStateManager` for that specific miner. The main application can then retrieve these instructions and transmit them back to the miner's device.

This cycle repeats for every data packet received, ensuring that miners have a constantly updated location and escape route.